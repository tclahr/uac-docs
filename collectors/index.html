<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://github.com/tclahr/uac/collectors/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Collectors - UAC Documentation</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
        <link href="../extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Collectors";
        var mkdocs_page_input_path = "collectors.md";
        var mkdocs_page_url = "/tclahr/uac/collectors/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> UAC Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">BASICS</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="..">Getting started</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">DEFINITIONS</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../profile_file/">Profile file</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../artifacts_file/">Artifacts file</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">Collectors</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#command-collector">command collector</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#command">command</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#loop_command">loop_command</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#output_file">output_file</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#output_directory">output_directory</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#compressed_output_file">compressed_output_file</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exclude_nologin_users">exclude_nologin_users</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#find-collector">find collector</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#path">path</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#path_pattern">path_pattern</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#name_pattern">name_pattern</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exclude_path_pattern">exclude_path_pattern</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exclude_name_pattern">exclude_name_pattern</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exclude_file_system">exclude_file_system</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#max_depth">max_depth</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#file_type">file_type</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#min_file_size">min_file_size</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#max_file_size">max_file_size</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#permissions">permissions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ignore_date_range">ignore_date_range</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exclude_nologin_users_1">exclude_nologin_users</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#output_file_1">output_file</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#output_directory_1">output_directory</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#hash-collector">hash collector</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#path_1">path</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#is_file_list">is_file_list</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#path_pattern_1">path_pattern</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#name_pattern_1">name_pattern</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exclude_path_pattern_1">exclude_path_pattern</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exclude_name_pattern_1">exclude_name_pattern</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exclude_file_system_1">exclude_file_system</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#max_depth_1">max_depth</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#file_type_1">file_type</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#min_file_size_1">min_file_size</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#max_file_size_1">max_file_size</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#permissions_1">permissions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ignore_date_range_1">ignore_date_range</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exclude_nologin_users_2">exclude_nologin_users</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#output_file_2">output_file</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#output_directory_2">output_directory</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#stat-collector">stat collector</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#path_2">path</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#is_file_list_1">is_file_list</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#path_pattern_2">path_pattern</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#name_pattern_2">name_pattern</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exclude_path_pattern_2">exclude_path_pattern</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exclude_name_pattern_2">exclude_name_pattern</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exclude_file_system_2">exclude_file_system</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#max_depth_2">max_depth</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#file_type_2">file_type</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#min_file_size_2">min_file_size</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#max_file_size_2">max_file_size</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#permissions_2">permissions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ignore_date_range_2">ignore_date_range</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exclude_nologin_users_3">exclude_nologin_users</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#output_file_3">output_file</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#output_directory_3">output_directory</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#file-collector">file collector</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#path_3">path</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#is_file_list_2">is_file_list</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#path_pattern_3">path_pattern</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#name_pattern_3">name_pattern</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exclude_path_pattern_3">exclude_path_pattern</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exclude_name_pattern_3">exclude_name_pattern</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exclude_file_system_3">exclude_file_system</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#max_depth_3">max_depth</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#file_type_3">file_type</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#min_file_size_3">min_file_size</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#max_file_size_3">max_file_size</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#permissions_3">permissions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ignore_date_range_3">ignore_date_range</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exclude_nologin_users_4">exclude_nologin_users</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../exposed_vars/">Exposed variables</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">OUTPUT FILE</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../output_file/">Output file format</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">UAC Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>DEFINITIONS &raquo;</li><li>Collectors</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>

          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="collectors">Collectors</h1>
<h2 id="command-collector">command collector</h2>
<p>Use this collector to run commands and store the output into an output file.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Report a snapshot of the current processes.
    supported_os: [all]
    collector: command
    command: ps
    output_file: ps.txt
  -
    description: Report a snapshot of the current processes.
    supported_os: [aix, freebsd, linux, macos, netbsd, openbsd, solaris]
    collector: command
    command: ps auxwww
    output_file: ps_auxwww.txt
  -
    description: Extract strings from running processes.
    supported_os: [aix]
    collector: command
    loop_command: for pid in /proc/[0-9]*; do echo ${pid} | sed -e 's:/proc/::'; done
    command: strings -a /proc/%line%/object/a.out
    output_directory: proc/%line%
    output_file: strings.txt
    compress_output_file: true
</code></pre>
<h3 id="command">command</h3>
<p><span class="required">Required</span></p>
<p>The command that will be run in the target system and the output will be collected from.</p>
<p>The path to the executable is not required. Only the name of the executable and the parameters should be given.</p>
<p>UAC can also run executables located in the <code>bin</code> directory. Even in this case the path to the executable is not required. The <code>bin</code> directory is always added to PATH when UAC starts. Please refer to <code>bin/README.md</code> file for more information.</p>
<p>The example below shows how to collect the output from <code>ps -ef</code> command:</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Report a snapshot of the current processes.
    supported_os: [all]
    collector: command
    command: ps -ef
    output_file: ps_-ef.txt
</code></pre>
<h3 id="loop_command">loop_command</h3>
<p><span class="optional">Optional</span></p>
<p>The command that will be run and the output lines will be used as the input for the <a href="#command">command</a> option.</p>
<p>The logic behind it is:</p>
<pre><code>for (each line returned by loop_command); do
  command
done
</code></pre>
<p>There is one variable that can be used that will be replaced by UAC at runtime:</p>
<table>
<thead>
<tr>
<th>VARIABLE NAME</th>
<th>DESCRIPTION</th>
</tr>
</thead>
<tbody>
<tr>
<td>%line%</td>
<td>Replaced with each line returned by the execution of the loop_command command</td>
</tr>
</tbody>
</table>
<p>Let's suppose you need to collect containers logs, and you don't know the containers IDs. First you need to retrieve all the IDs: <code>docker container ps -all | sed 1d | awk '{print $1}'</code></p>
<p>The <code>%line%</code> variable will be replaced by each output line resulted from that command (which are containers IDs in the example above).</p>
<p>This means if you have 10 containers, the command <code>docker container logs %line%</code> will be run 10 times, one for each container ID. Example:</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Fetch the logs of all containers.
    supported_os: [linux]
    collector: command
    loop_command: docker container ps -all | sed 1d | awk '{print $1}'
    command: docker container logs %line%
    output_file: docker_container_logs_%line%.txt
</code></pre>
<h3 id="output_file">output_file</h3>
<p><span class="required">Required</span></p>
<p>Output file name where collected data will be stored in. UAC never overwrites output files. Data will be appended to file if the same file name is set for a different artifact rule within the same artifact directory.</p>
<p>Both <code>ps</code> and <code>ps auxwww</code> outputs will be stored into the same <code>ps.txt</code> file in the example below.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Report a snapshot of the current processes.
    supported_os: [all]
    collector: command
    command: ps
    output_file: ps.txt
  -
    description: Report a snapshot of the current processes.
    supported_os: [all]
    collector: command
    command: ps auxwww
    output_file: ps.txt
</code></pre>
<h3 id="output_directory">output_directory</h3>
<p><span class="optional">Optional</span></p>
<p>Defines the subdirectory name the output file will be stored in.</p>
<p>By default, collected artifacts will always be stored into a directory which its path follows the same structure defined in the artifacts directory.</p>
<p>In the example below, the output file created by <code>bodyfile.yaml</code> will be stored into <code>bodyfile</code> directory, and the output files created by <code>docker.yaml</code> will be stored into <code>live_response/containers</code> directory.</p>
<p><img alt="screenshot" src="../img/output_directory_01.png" /></p>
<p>But in some cases it is preferred to have the output file stored into subdirectories. Let's use the <code>live_response/process/string_running_processes.yaml</code> as an example where the output file is stored into <code>live_response/process/proc/%line%</code> subdirectory. </p>
<pre><code class="language-yaml">artifacts:
  -
    description: Extract strings from running processes.
    supported_os: [android, linux, netbsd]
    collector: command
    loop_command: for pid in /proc/[0-9]*; do echo ${pid} | sed -e 's:/proc/::'; done
    command: strings -a /proc/%line%/exe
    output_directory: proc/%line%
    output_file: strings.txt
    compress_output_file: true
</code></pre>
<h3 id="compressed_output_file">compressed_output_file</h3>
<p><span class="optional">Optional</span></p>
<p>The output file will be compressed by gzip if this option is set to <code>true</code>.</p>
<p>The following artifact will have its output stored into the compressed output file <code>ps_-ef.txt.gz</code> in the example below.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Report a snapshot of the current processes.
    supported_os: [all]
    collector: command
    command: ps -ef
    output_file: ps_-ef.txt
    compress_output_file: true
</code></pre>
<h3 id="exclude_nologin_users">exclude_nologin_users</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to search artifacts from users that have a valid shell only. Any user that has no shell or a shell set as false, halt, nologin, shutdown or sync will be skipped from the collection.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Run 'ls -lRa' on all home directories for users that have a valid shell only.
    supported_os: [all]
    collector: command
    command: ls -lRa /%user_home%/
    exclude_nologin_users: true
    output_file: ls_-lRa_%user%.txt
</code></pre>
<h2 id="find-collector">find collector</h2>
<p>Use this collector to find files and directories using either <code>find</code> or <code>find.pl</code> tool, and store the output into a text file. </p>
<pre><code class="language-yaml">artifacts:
  -
    description: Find files that contain at least +x flag set for other.
    supported_os: [all]
    collector: find
    path: /
    exclude_file_system: [proc, procfs]
    file_type: f
    max_depth: 4
    max_file_size: 3072000
    permissions: -001
    output_file: list_of_executable_files.txt

</code></pre>
<h3 id="path">path</h3>
<p><span class="required">Required</span></p>
<p>The starting point from where the artifact will be searched for. UAC will recurse into subdirectories unless otherwise prevented by <code>max_depth</code> option.</p>
<p>As UAC uses <code>find</code> tool to search for artifacts, wildcards and regex patterns are also supported here.</p>
<p>Every artifact should be treated like it originates on the / (root) mount point. The root mount point will be replaced by UAC if a new mount point is set with <code>--mount-point</code> command line option.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Search all cmdline files within /proc/*/
    supported_os: [all]
    collector: find
    path: /proc/*/cmdline
    output_file: cmdline.txt
</code></pre>
<p>For keeping consistences across all supported operating systems (and different <code>find</code> tool versions), it is recommended that all directory names ends with a <code>/*</code> (slash asterisks).</p>
<p>Search all files and directories within <code>/etc</code>. Note the use of a <code>*</code> at the end of the path.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Search all files and directories within /etc.
    supported_os: [all]
    collector: find
    path: /etc/*
    output_file: etc.txt
</code></pre>
<p>Note that you need to use quotation marks when specifying paths with spaces.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Search for TCC.db file.
    supported_os: [all]
    collector: find
    path: /Library/&quot;Application Support&quot;/com.apple.TCC/TCC.db
    output_file: path_with_spaces.txt
</code></pre>
<h3 id="path_pattern">path_pattern</h3>
<p><span class="optional">Optional</span></p>
<p>Return the full file path if one of path_pattern values matches the file path. This option works exactly the same way as find's -path option.</p>
<p>Don't forget to enclose the pattern in double quotes. Use backslash (\) to escape double quotes and commas.</p>
<p>As UAC uses <code>find</code> tool to search for artifacts, wildcards and regex patterns are also supported here.</p>
<p>The example below searches for Discord's Cache directory anywhere within the user's home directory. Hits would be as follows:</p>
<ul>
<li>/home/user/.config<span style="color: red;">/discord/Cache/</span>00bcecbd2455cb22_0</li>
<li>/home/user/.var/app/com.discordapp.Discord/config<span style="color: red;">/discord/Cache/</span>index</li>
<li>/home/user/snap/discord/current/.config<span style="color: red;">/discord/Cache/</span>ac0fa118bdaaa62e_0</li>
</ul>
<pre><code class="language-yaml">artifacts:
  -
    description: Find Discord cache files.
    supported_os: [all]
    collector: find
    path: /%user_home%
    path_pattern: [&quot;*/discord/Cache/*&quot;]
    output_file: discord_cache.txt
</code></pre>
<h3 id="name_pattern">name_pattern</h3>
<p><span class="optional">Optional</span></p>
<p>Return the full file path if one of the name_pattern values matches the file name. This option works exactly the same way as find's -name option.</p>
<p>Because the leading directories are removed, the file names considered for a match with name_pattern will never include a slash, so <code>"a/b"</code> will never match anything.</p>
<p>Don't forget to enclose the pattern in double quotes. Use backslash (\) to escape double quotes and commas.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Search all wtmp and utmp files.
    supported_os: [all]
    collector: find
    path: /var/*
    name_pattern: [&quot;wtmp&quot;, &quot;btmp&quot;]
    output_file: wtmp_btmp.txt
</code></pre>
<p>As UAC uses <code>find</code> tool to search for artifacts, wildcards and regex patterns are also supported here.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Search all HTML and TXT files.
    supported_os: [all]
    collector: find
    path: /*
    name_pattern: [&quot;*.html&quot;, &quot;*.txt&quot;]
    output_file: all_html_txt.txt
</code></pre>
<pre><code class="language-yaml">artifacts:
  -
    description: Search all .log and .Log (capital L) files.
    supported_os: [all]
    collector: find
    path: /var/log/*
    name_pattern: [&quot;*.[Ll]og&quot;]
    output_file: all_log_files.txt
</code></pre>
<h3 id="exclude_path_pattern">exclude_path_pattern</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to exclude paths from the collection. This option works exactly the same way as find's -path -prune option.</p>
<p>Don't forget to enclose the pattern in double quotes. Use backslash (\) to escape double quotes and commas.</p>
<p>As UAC uses <code>find</code> tool to search for artifacts, wildcards and regex patterns are also supported here.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Search all excluding /etc and /var.
    supported_os: [all]
    collector: find
    path: /*
    exclude_path_pattern: [&quot;/dev&quot;, &quot;/var&quot;]
    output_file: all_excluding_etc_var.txt
</code></pre>
<h3 id="exclude_name_pattern">exclude_name_pattern</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to exclude files from the collection. This option works exactly the same way as find's -name -prune option.</p>
<p>Because the leading directories are removed, the file names considered for a match with exclude_name_pattern will never include a slash, so <code>"a/b"</code> will never match anything.</p>
<p>Don't forget to enclose the pattern in double quotes. Use backslash (\) to escape double quotes and commas.</p>
<p>As UAC uses <code>find</code> tool to search for artifacts, wildcards and regex patterns are also supported here.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Search /etc excluding passwd and shadow* files.
    supported_os: [all]
    collector: find
    path: /etc/*
    exclude_name_pattern: [&quot;passwd&quot;, &quot;shadow*&quot;]
    output_file: etc_excluding_passwd_shadow.txt
</code></pre>
<h3 id="exclude_file_system">exclude_file_system</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to exclude file systems from the collection. UAC will retrieve the list of existing mountpoints (paths) and exclude them from the collection.</p>
<p>The file system types which are supported depend on the target computer's running kernel.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Search all files excluding any files located in procfs, nfs and devfs file systems.
    supported_os: [all]
    collector: find
    path: /*
    exclude_file_system: [procfs, nfs, devfs]
    output_file: exclude_procfs_nfs_devfs.txt
</code></pre>
<h3 id="max_depth">max_depth</h3>
<p><span class="optional">Optional</span></p>
<p>Descend at most levels (a non-negative integer) levels of directories below the starting-point. Using 0 means only apply the tests and actions to the starting-points themselves. This option works exactly the same way as find's -maxdepth option.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Descend at most 5 levels of directories below /.
    supported_os: [all]
    collector: find
    path: /*
    max_depth: 5
    output_file: max_5_levels.txt
</code></pre>
<h3 id="file_type">file_type</h3>
<p><span class="optional">Optional</span></p>
<p>This option works exactly the same way as find's -type option.</p>
<p>File is of type:</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>f</td>
<td>regular file</td>
</tr>
<tr>
<td>d</td>
<td>directory</td>
</tr>
<tr>
<td>l</td>
<td>symbolic link</td>
</tr>
<tr>
<td>p</td>
<td>named pipe (FIFO)</td>
</tr>
<tr>
<td>s</td>
<td>socket</td>
</tr>
<tr>
<td>b</td>
<td>block special</td>
</tr>
<tr>
<td>c</td>
<td>character special</td>
</tr>
</tbody>
</table>
<pre><code class="language-yaml">artifacts:
  -
    description: Search files only.
    supported_os: [all]
    collector: find
    path: /*
    file_type: f
    output_file: files_only.txt
</code></pre>
<pre><code class="language-yaml">artifacts:
  -
    description: Search directories only.
    supported_os: [all]
    collector: find
    path: /*
    file_type: d
    output_file: directories_only.txt
</code></pre>
<h3 id="min_file_size">min_file_size</h3>
<p><span class="optional">Optional</span></p>
<p>The minimum size of a file to search, in bytes. Any files smaller than this will be ignored.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Search all files bigger than 1048576 bytes.
    supported_os: [all]
    collector: find
    path: /*
    file_type: f
    min_file_size: 1048576
    output_file: bigger_than.txt
</code></pre>
<h3 id="max_file_size">max_file_size</h3>
<p><span class="optional">Optional</span></p>
<p>The maximum size of a file to search, in bytes. Any files bigger than this will be ignored.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Search all files smaller than 1048576 bytes.
    supported_os: [all]
    collector: find
    path: /*
    file_type: f
    max_file_size: 1048576
    output_file: smaller_than.txt
</code></pre>
<h3 id="permissions">permissions</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to search for files and directories based on their permissions. This option works exactly the same way as find's -perm option.</p>
<p>Please note that symbolic mode is not supported (e.g: -g=w).</p>
<p>Permissions can be used as follows:</p>
<ul>
<li>File's permission bits are exactly <code>mode</code> (octal).</li>
</ul>
<pre><code class="language-yaml">artifacts:
  -
    description: Search files that have permissions set to 755.
    supported_os: [all]
    collector: find
    path: /*
    file_type: f
    permissions: 755
    output_file: all_755_permissions.txt
</code></pre>
<ul>
<li>All of the permission bits <code>mode</code> (octal) are set for the file.</li>
</ul>
<pre><code class="language-yaml">artifacts:
  -
    description: Search for files that have SUID bit set.
    supported_os: [all]
    collector: find
    path: /*
    file_type: f
    permissions: -4000
    output_file: suid_files.txt
</code></pre>
<h3 id="ignore_date_range">ignore_date_range</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to collect files ignoring the date set using both --date-range-start and --date-range-end command line options.</p>
<p>This is useful when you want to set a date range for your collection, but want to collect some files regardless their last accessed, modified and changed dates.</p>
<p>Example, search for all files and subdirecties from /etc regardless their last accessed, modified and changed dates, even if a date range was set using --date-range-start and --date-range-end command line options.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Search /etc regardless date range set by --date-range-start and --date-range-end.
    supported_os: [all]
    collector: find
    path: /etc/*
    ignore_date_range: true
    output_file: ignore_date_range.txt
</code></pre>
<h3 id="exclude_nologin_users_1">exclude_nologin_users</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to search artifacts from users that have a valid shell only. Any user that has no shell or a shell set as false, halt, nologin, shutdown or sync will be skipped from the collection.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Collect .bash_history file from users that have a valid shell only.
    supported_os: [all]
    collector: find
    path: /%user_home%/.bash_history
    exclude_nologin_users: true
    output_file: exclude_nologin_users.txt
</code></pre>
<h3 id="output_file_1">output_file</h3>
<p><span class="required">Required</span></p>
<p>Output file name where the list of files will be stored in. UAC never overwrites output files. Data will be appended to file if the same file name is set for a different artifact rule within the same artifact directory.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Search all files and directories from /etc.
    supported_os: [all]
    collector: find
    path: /etc/*
    output_file: same_output_file.txt
  -
    description: Search all files and directories from /var/log.
    supported_os: [all]
    collector: find
    path: /var/log/*
    output_file: same_output_file.txt
</code></pre>
<h3 id="output_directory_1">output_directory</h3>
<p><span class="optional">Optional</span></p>
<p>Defines the subdirectory name the output file will be stored in.</p>
<p>By default, collected artifacts will always be stored into a directory which its path follows the same structure defined in the artifacts directory.</p>
<p>In the example below, the output file created by <code>bodyfile.yaml</code> will be stored into <code>bodyfile</code> directory, and the output files created by <code>docker.yaml</code> will be stored into <code>live_response/containers</code> directory.</p>
<p><img alt="screenshot" src="../img/output_directory_01.png" /></p>
<p>But in some cases it is preferred to have the output file stored into subdirectories. Let's use the <code>live_response/process/string_running_processes.yaml</code> as an example where the output file is stored into <code>live_response/process/proc/%line%</code> subdirectory. </p>
<pre><code class="language-yaml">artifacts:
  -
    description: Extract strings from running processes.
    supported_os: [android, linux, netbsd]
    collector: command
    loop_command: for pid in /proc/[0-9]*; do echo ${pid} | sed -e 's:/proc/::'; done
    command: strings -a /proc/%line%/exe
    output_directory: proc/%line%
    output_file: strings.txt
    compress_output_file: true
</code></pre>
<h2 id="hash-collector">hash collector</h2>
<p>Use this collector to hash files and store the output into a text file. Hash algorithms that will be used during collection are defined in <code>config/uac.conf</code> file.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Hash all files smaller than 3072000 bytes.
    supported_os: [all]
    collector: hash
    path: /*
    exclude_file_system: [proc, procfs]
    file_type: f
    max_depth: 4
    max_file_size: 3072000
    output_file: hash.txt

</code></pre>
<h3 id="path_1">path</h3>
<p><span class="required">Required</span></p>
<p>The starting point from where the files will be searched for. UAC will recurse into subdirectories unless otherwise prevented by <code>max_depth</code> option.</p>
<p>As UAC uses <code>find</code> tool to search for artifacts, wildcards and regex patterns are also supported here.</p>
<p>Every file should be treated like it originates on the / (root) mount point. The root mount point will be replaced by UAC if a new mount point is set with <code>--mount-point</code> command line option.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Hash /bin/sh file.
    supported_os: [all]
    collector: hash
    path: /bin/sh
    output_file: hash_bin_sh.txt
</code></pre>
<p>For keeping consistences across all supported operating systems (and different <code>find</code> tool versions), it is recommended that all directory names ends with a <code>/*</code> (slash asterisks).</p>
<p>Hash all files  within <code>/etc</code>. Note the use of a <code>*</code> at the end of the path.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Hash all files and directories within /etc.
    supported_os: [all]
    collector: hash
    path: /etc/*
    output_file: hashes_etc.txt
</code></pre>
<p>Note that you need to use quotation marks when specifying paths with spaces.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Hash TCC.db file.
    supported_os: [all]
    collector: hash
    path: /Library/&quot;Application Support&quot;/com.apple.TCC/TCC.db
    output_file: path_with_spaces.txt
</code></pre>
<h3 id="is_file_list">is_file_list</h3>
<p><span class="optional">Optional</span></p>
<p>If set to true, the <code>path</code> option will refer to a file list containing one path per line. This is useful when you need to hash files based on a file list.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Hash files based on a file list located in /%uac_directory%/my_file_list.txt.
    supported_os: [all]
    collector: hash
    path: /%uac_directory%/my_file_list.txt
    is_file_list: true
    output_file: hash_my_file_list.txt
</code></pre>
<h3 id="path_pattern_1">path_pattern</h3>
<p><span class="optional">Optional</span></p>
<p>Return the full file path if one of path_pattern values matches the file path. This option works exactly the same way as find's -path option.</p>
<p>Don't forget to enclose the pattern in double quotes. Use backslash (\) to escape double quotes and commas.</p>
<p>As UAC uses <code>find</code> tool to search for artifacts, wildcards and regex patterns are also supported here.</p>
<p>The example below searches for Discord's Cache directory anywhere within the user's home directory. Hits would be as follows:</p>
<ul>
<li>/home/user/.config<span style="color: red;">/discord/Cache/</span>00bcecbd2455cb22_0</li>
<li>/home/user/.var/app/com.discordapp.Discord/config<span style="color: red;">/discord/Cache/</span>index</li>
<li>/home/user/snap/discord/current/.config<span style="color: red;">/discord/Cache/</span>ac0fa118bdaaa62e_0</li>
</ul>
<pre><code class="language-yaml">artifacts:
  -
    description: Find Discord cache files.
    supported_os: [all]
    collector: hash
    path: /%user_home%
    path_pattern: [&quot;*/discord/Cache/*&quot;]
    output_file: discord_cache
</code></pre>
<h3 id="name_pattern_1">name_pattern</h3>
<p><span class="optional">Optional</span></p>
<p>Return the full file path if one of the values of name_pattern matches the file name. This option works exactly the same way as find's -name option.</p>
<p>Because the leading directories are removed, the file names considered for a match with name_pattern will never include a slash, so <code>"a/b"</code> will never match anything.</p>
<p>Don't forget to enclose the pattern in double quotes. Use backslash (\) to escape double quotes and commas.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Hash all wtmp and utmp files.
    supported_os: [all]
    collector: hash
    path: /var/*
    name_pattern: [&quot;wtmp&quot;, &quot;btmp&quot;]
    output_file: hash_wtmp_btmp.txt
</code></pre>
<p>As UAC uses <code>find</code> tool to search for artifacts, wildcards and regex patterns are also supported here.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Hash all HTML and TXT files.
    supported_os: [all]
    collector: hash
    path: /*
    name_pattern: [&quot;*.html&quot;, &quot;*.txt&quot;]
    output_file: hash_all_html_txt
</code></pre>
<pre><code class="language-yaml">artifacts:
  -
    description: Hash all .log and .Log (capital L) files.
    supported_os: [all]
    collector: hash
    path: /var/log/*
    name_pattern: [&quot;*.[Ll]og&quot;]
    output_file: hash_all_log_files
</code></pre>
<h3 id="exclude_path_pattern_1">exclude_path_pattern</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to exclude paths from the collection. This option works exactly the same way as find's -path -prune option.</p>
<p>Don't forget to enclose the pattern in double quotes. Use backslash (\) to escape double quotes and commas.</p>
<p>As UAC uses <code>find</code> tool to search for artifacts, wildcards and regex patterns are also supported here.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Hash all files excluding /etc and /var.
    supported_os: [all]
    collector: hash
    path: /*
    exclude_path_pattern: [&quot;/dev&quot;, &quot;/var&quot;]
    output_file: all_excluding_etc_var.txt
</code></pre>
<h3 id="exclude_name_pattern_1">exclude_name_pattern</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to exclude files from the collection. This option works exactly the same way as find's -name -prune option.</p>
<p>Because the leading directories are removed, the file names considered for a match with exclude_name_pattern will never include a slash, so <code>"a/b"</code> will never match anything.</p>
<p>Don't forget to enclose the pattern in double quotes. Use backslash (\) to escape double quotes and commas.</p>
<p>As UAC uses <code>find</code> tool to search for artifacts, wildcards and regex patterns are also supported here.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Hash all from /etc excluding passwd and shadow* files.
    supported_os: [all]
    collector: hash
    path: /etc/*
    exclude_name_pattern: [&quot;passwd&quot;, &quot;shadow*&quot;]
    output_file: hash_etc_excluding_passwd_shadow.txt
</code></pre>
<h3 id="exclude_file_system_1">exclude_file_system</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to exclude file systems from the collection. UAC will retrieve the list of existing mountpoints (paths) and exclude them from the collection.</p>
<p>The file system types which are supported depend on the target computer's running kernel.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Hash all files excluding any files located in procfs, nfs and devfs file systems.
    supported_os: [all]
    collector: hash
    path: /*
    exclude_file_system: [procfs, nfs, devfs]
    file_type: f
    output_file: hash_all_exclude_procfs_nfs_devfs.txt
</code></pre>
<h3 id="max_depth_1">max_depth</h3>
<p><span class="optional">Optional</span></p>
<p>Descend at most levels (a non-negative integer) levels of directories below the starting-point. Using 0 means only apply the tests and actions to the starting-points themselves. This option works exactly the same way as find's -maxdepth option.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Descend at most 5 levels of directories below /.
    supported_os: [all]
    collector: hash
    path: /*
    max_depth: 5
    output_file: hash_max_5_levels.txt
</code></pre>
<h3 id="file_type_1">file_type</h3>
<p><span class="optional">Optional</span></p>
<p>This option works exactly the same way as find's -type option.</p>
<p>File is of type:</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>f</td>
<td>regular file</td>
</tr>
<tr>
<td>d</td>
<td>directory</td>
</tr>
<tr>
<td>l</td>
<td>symbolic link</td>
</tr>
<tr>
<td>p</td>
<td>named pipe (FIFO)</td>
</tr>
<tr>
<td>s</td>
<td>socket</td>
</tr>
<tr>
<td>b</td>
<td>block special</td>
</tr>
<tr>
<td>c</td>
<td>character special</td>
</tr>
</tbody>
</table>
<pre><code class="language-yaml">artifacts:
  -
    description: Hash files only
    supported_os: [all]
    collector: find
    path: /*
    file_type: f
    output_file: files_only.txt
</code></pre>
<h3 id="min_file_size_1">min_file_size</h3>
<p><span class="optional">Optional</span></p>
<p>The minimum size of a file to hash, in bytes. Any files smaller than this will be ignored.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Hash all files bigger than 1048576 bytes
    supported_os: [all]
    collector: hash
    path: /*
    file_type: f
    min_file_size: 1048576
    output_file: hash_bigger_than.txt
</code></pre>
<h3 id="max_file_size_1">max_file_size</h3>
<p><span class="optional">Optional</span></p>
<p>The maximum size of a file to hash, in bytes. Any files bigger than this will be ignored.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Hash all files smaller than 1048576 bytes
    supported_os: [all]
    collector: hash
    path: /*
    file_type: f
    max_file_size: 1048576
    output_file: hash_smaller_than.txt
</code></pre>
<h3 id="permissions_1">permissions</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to hash files based on their permissions. This option works exactly the same way as find's -perm option.</p>
<p>Please note that symbolic mode is not supported (e.g: -g=w).</p>
<p>Permissions can be used as follows:</p>
<ul>
<li>File's permission bits are exactly <code>mode</code> (octal).</li>
</ul>
<pre><code class="language-yaml">artifacts:
  -
    description: Hash files that have permissions set to 755.
    supported_os: [all]
    collector: hash
    path: /*
    file_type: f
    permissions: 755
    output_file: hash_all_755_permissions.txt
</code></pre>
<ul>
<li>All of the permission bits <code>mode</code> (octal) are set for the file.</li>
</ul>
<pre><code class="language-yaml">artifacts:
  -
    description: Hash all files that have SUID bit set.
    supported_os: [all]
    collector: hash
    path: /*
    file_type: f
    permissions: -4000
    output_file: hash_suid_files.txt
</code></pre>
<h3 id="ignore_date_range_1">ignore_date_range</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to hash files ignoring the date set using both --date-range-start and --date-range-end command line options.</p>
<p>This is useful when you want to set a date range for your collection, but want to hash some files regardless their last accessed, modified and changed dates.</p>
<p>Example, hash for all files and subdirecties from /etc regardless their last accessed, modified and changed dates, even if a date range was set using --date-range-start and --date-range-end command line options.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Hash all files from /etc regardless date range set by --date-range-start and --date-range-end.
    supported_os: [all]
    collector: hash
    path: /etc/*
    ignore_date_range: true
    output_file: hash_ignore_date_range.txt
</code></pre>
<h3 id="exclude_nologin_users_2">exclude_nologin_users</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to hash files from users that have a valid shell only. Any user that has no shell or a shell set as false, halt, nologin, shutdown or sync will be skipped from the collection.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Hash .bash_history file from users that have a valid shell only.
    supported_os: [all]
    collector: hash
    path: /%user_home%/.bash_history
    exclude_nologin_users: true
    output_file: hash_exclude_nologin_users.txt
</code></pre>
<h3 id="output_file_2">output_file</h3>
<p><span class="required">Required</span></p>
<p>Output file name where the hashes will be stored in. UAC never overwrites output files. Data will be appended to file if the same file name is set for a different artifact rule within the same artifact directory.</p>
<p>The proper file extension (.md5, .sha1 or .sha256) will be added automatically to the output file according to the hash algorithm used to hash the files. In the example below, the output file will be <code>same_output_file.txt.md5</code> and <code>same_output_file.txt.sha256</code> if MD5 and SHA256 algorithms were set in <code>config/uac.conf</code> file.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Hash all files and directories from /etc.
    supported_os: [all]
    collector: hash
    path: /etc/*
    output_file: same_output_file.txt
  -
    description: Hash all files and directories from /var/log.
    supported_os: [all]
    collector: hash
    path: /var/log/*
    output_file: same_output_file.txt
</code></pre>
<h3 id="output_directory_2">output_directory</h3>
<p><span class="optional">Optional</span></p>
<p>Defines the subdirectory name the output file will be stored in.</p>
<p>By default, collected artifacts will always be stored into a directory which its path follows the same structure defined in the artifacts directory.</p>
<p>In the example below, the output file created by <code>bodyfile.yaml</code> will be stored into <code>bodyfile</code> directory, and the output files created by <code>docker.yaml</code> will be stored into <code>live_response/containers</code> directory.</p>
<p><img alt="screenshot" src="../img/output_directory_01.png" /></p>
<p>But in some cases it is preferred to have the output file stored into subdirectories. Let's use the <code>live_response/process/string_running_processes.yaml</code> as an example where the output file is stored into <code>live_response/process/proc/%line%</code> subdirectory. </p>
<pre><code class="language-yaml">artifacts:
  -
    description: Extract strings from running processes.
    supported_os: [android, linux, netbsd]
    collector: command
    loop_command: for pid in /proc/[0-9]*; do echo ${pid} | sed -e 's:/proc/::'; done
    command: strings -a /proc/%line%/exe
    output_directory: proc/%line%
    output_file: strings.txt
    compress_output_file: true
</code></pre>
<h2 id="stat-collector">stat collector</h2>
<p>Use this collector to extract information from files and directories using either <code>stat</code> or <code>stat.pl</code> tool to create a body file. The body file is an intermediate file when creating a timeline of file activity. It is a pipe ("|") delimited text file that contains one line for each file. <a href="https://github.com/log2timeline/plaso">Plaso</a> and <a href="https://wiki.sleuthkit.org/index.php?title=Mactime">mactime</a> tools can be used to read this file and sorts the contents.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Stat all files.
    supported_os: [all]
    collector: stat
    path: /*
    file_type: f
    output_file: stat.txt

</code></pre>
<h3 id="path_2">path</h3>
<p><span class="required">Required</span></p>
<p>The starting point from where the files will be searched for. UAC will recurse into subdirectories unless otherwise prevented by <code>max_depth</code> option.</p>
<p>As UAC uses <code>find</code> tool to search for artifacts, wildcards and regex patterns are also supported here.</p>
<p>Every file should be treated like it originates on the / (root) mount point. The root mount point will be replaced by UAC if a new mount point is set with <code>--mount-point</code> command line option.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Stat /bin/sh file.
    supported_os: [all]
    collector: stat
    path: /bin/sh
    output_file: stat_bin_sh.txt
</code></pre>
<p>For keeping consistences across all supported operating systems (and different <code>find</code> tool versions), it is recommended that all directory names ends with a <code>/*</code> (slash asterisks).</p>
<p>Stat all files  within <code>/etc</code>. Note the use of a <code>*</code> at the end of the path.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Stat all files and directories within /etc.
    supported_os: [all]
    collector: stat
    path: /etc/*
    output_file: stat_etc.txt
</code></pre>
<p>Note that you need to use quotation marks when specifying paths with spaces.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Stat TCC.db file.
    supported_os: [all]
    collector: stat
    path: /Library/&quot;Application Support&quot;/com.apple.TCC/TCC.db
    output_file: path_with_spaces.txt
</code></pre>
<h3 id="is_file_list_1">is_file_list</h3>
<p><span class="optional">Optional</span></p>
<p>If set to true, the <code>path</code> option will refer to a file list containing one path per line. This is useful when you need to stat files based on a file list.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Stat files based on a file list located in /%uac_directory%/my_file_list.txt.
    supported_os: [all]
    collector: stat
    path: /%uac_directory%/my_file_list.txt
    is_file_list: true
    output_file: stat_my_file_list.txt
</code></pre>
<h3 id="path_pattern_2">path_pattern</h3>
<p><span class="optional">Optional</span></p>
<p>Return the full file path if one of path_pattern values matches the file path. This option works exactly the same way as find's -path option.</p>
<p>Don't forget to enclose the pattern in double quotes. Use backslash (\) to escape double quotes and commas.</p>
<p>As UAC uses <code>find</code> tool to search for artifacts, wildcards and regex patterns are also supported here.</p>
<p>The example below searches for Discord's Cache directory anywhere within the user's home directory. Hits would be as follows:</p>
<ul>
<li>/home/user/.config<span style="color: red;">/discord/Cache/</span>00bcecbd2455cb22_0</li>
<li>/home/user/.var/app/com.discordapp.Discord/config<span style="color: red;">/discord/Cache/</span>index</li>
<li>/home/user/snap/discord/current/.config<span style="color: red;">/discord/Cache/</span>ac0fa118bdaaa62e_0</li>
</ul>
<pre><code class="language-yaml">artifacts:
  -
    description: Find Discord cache files.
    supported_os: [all]
    collector: stat
    path: /%user_home%
    path_pattern: [&quot;*/discord/Cache/*&quot;]
    output_file: discord_cache.txt
</code></pre>
<h3 id="name_pattern_2">name_pattern</h3>
<p><span class="optional">Optional</span></p>
<p>Return the full file path if one of the values of name_pattern matches the file name. This option works exactly the same way as find's -name option.</p>
<p>Because the leading directories are removed, the file names considered for a match with name_pattern will never include a slash, so <code>"a/b"</code> will never match anything.</p>
<p>Don't forget to enclose the pattern in double quotes. Use backslash (\) to escape double quotes and commas.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Stat all wtmp and utmp files.
    supported_os: [all]
    collector: stat
    path: /var/*
    name_pattern: [&quot;wtmp&quot;, &quot;btmp&quot;]
    output_file: stat_wtmp_btmp.txt
</code></pre>
<p>As UAC uses <code>find</code> tool to search for artifacts, wildcards and regex patterns are also supported here.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Stat all HTML and TXT files.
    supported_os: [all]
    collector: stat
    path: /*
    name_pattern: [&quot;*.html&quot;, &quot;*.txt&quot;]
    output_file: stat_all_html_txt
</code></pre>
<pre><code class="language-yaml">artifacts:
  -
    description: Stat all .log and .Log (capital L) files.
    supported_os: [all]
    collector: stat
    path: /var/log/*
    name_pattern: [&quot;*.[Ll]og&quot;]
    output_file: stat_all_log_files
</code></pre>
<h3 id="exclude_path_pattern_2">exclude_path_pattern</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to exclude paths from the collection. This option works exactly the same way as find's -path -prune option.</p>
<p>Don't forget to enclose the pattern in double quotes. Use backslash (\) to escape double quotes and commas.</p>
<p>As UAC uses <code>find</code> tool to search for artifacts, wildcards and regex patterns are also supported here.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Stat all files excluding /etc and /var.
    supported_os: [all]
    collector: stat
    path: /*
    exclude_path_pattern: [&quot;/dev&quot;, &quot;/var&quot;]
    output_file: stat_all_excluding_etc_var.txt
</code></pre>
<h3 id="exclude_name_pattern_2">exclude_name_pattern</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to exclude files from the collection. This option works exactly the same way as find's -name -prune option.</p>
<p>Because the leading directories are removed, the file names considered for a match with exclude_name_pattern will never include a slash, so <code>"a/b"</code> will never match anything.</p>
<p>Don't forget to enclose the pattern in double quotes. Use backslash (\) to escape double quotes and commas.</p>
<p>As UAC uses <code>find</code> tool to search for artifacts, wildcards and regex patterns are also supported here.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Stat all from /etc excluding passwd and shadow* files.
    supported_os: [all]
    collector: stat
    path: /etc/*
    exclude_name_pattern: [&quot;passwd&quot;, &quot;shadow*&quot;]
    output_file: stat_etc_excluding_passwd_shadow.txt
</code></pre>
<h3 id="exclude_file_system_2">exclude_file_system</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to exclude file systems from the collection. UAC will retrieve the list of existing mountpoints (paths) and exclude them from the collection.</p>
<p>The file system types which are supported depend on the target computer's running kernel.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Stat all files excluding any files located in procfs, nfs and devfs file systems.
    supported_os: [all]
    collector: stat
    path: /*
    exclude_file_system: [procfs, nfs, devfs]
    file_type: f
    output_file: stat_all_exclude_procfs_nfs_devfs.txt
</code></pre>
<h3 id="max_depth_2">max_depth</h3>
<p><span class="optional">Optional</span></p>
<p>Descend at most levels (a non-negative integer) levels of directories below the starting-point. Using 0 means only apply the tests and actions to the starting-points themselves. This option works exactly the same way as find's -maxdepth option.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Descend at most 5 levels of directories below /.
    supported_os: [all]
    collector: stat
    path: /*
    max_depth: 5
    output_file: stat_max_5_levels.txt
</code></pre>
<h3 id="file_type_2">file_type</h3>
<p><span class="optional">Optional</span></p>
<p>This option works exactly the same way as find's -type option.</p>
<p>File is of type:</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>f</td>
<td>regular file</td>
</tr>
<tr>
<td>d</td>
<td>directory</td>
</tr>
<tr>
<td>l</td>
<td>symbolic link</td>
</tr>
<tr>
<td>p</td>
<td>named pipe (FIFO)</td>
</tr>
<tr>
<td>s</td>
<td>socket</td>
</tr>
<tr>
<td>b</td>
<td>block special</td>
</tr>
<tr>
<td>c</td>
<td>character special</td>
</tr>
</tbody>
</table>
<pre><code class="language-yaml">artifacts:
  -
    description: Stat files only.
    supported_os: [all]
    collector: stat
    path: /*
    file_type: f
    output_file: stat_files_only.txt
</code></pre>
<pre><code class="language-yaml">artifacts:
  -
    description: Stat directories only.
    supported_os: [all]
    collector: stat
    path: /*
    file_type: d
    output_file: stat_directories_only.txt
</code></pre>
<h3 id="min_file_size_2">min_file_size</h3>
<p><span class="optional">Optional</span></p>
<p>The minimum size of a file to stat, in bytes. Any files smaller than this will be ignored.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Stat all files bigger than 1048576 bytes.
    supported_os: [all]
    collector: stat
    path: /*
    file_type: f
    min_file_size: 1048576
    output_file: stat_bigger_than.txt
</code></pre>
<h3 id="max_file_size_2">max_file_size</h3>
<p><span class="optional">Optional</span></p>
<p>The maximum size of a file to stat, in bytes. Any files bigger than this will be ignored.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Stat all files smaller than 1048576 bytes.
    supported_os: [all]
    collector: stat
    path: /*
    file_type: f
    max_file_size: 1048576
    output_file: stat_smaller_than.txt
</code></pre>
<h3 id="permissions_2">permissions</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to stat files based on their permissions. This option works exactly the same way as find's -perm option.</p>
<p>Please note that symbolic mode is not supported (e.g: -g=w).</p>
<p>Permissions can be used as follows:</p>
<ul>
<li>File's permission bits are exactly <code>mode</code> (octal).</li>
</ul>
<pre><code class="language-yaml">artifacts:
  -
    description: Stat files that have permissions set to 755.
    supported_os: [all]
    collector: stat
    path: /*
    file_type: f
    permissions: 755
    output_file: stat_all_755_permissions.txt
</code></pre>
<ul>
<li>All of the permission bits <code>mode</code> (octal) are set for the file.</li>
</ul>
<pre><code class="language-yaml">artifacts:
  -
    description: Stat all files that have SUID bit set.
    supported_os: [all]
    collector: stat
    path: /*
    file_type: f
    permissions: -4000
    output_file: stat_suid_files.txt
</code></pre>
<h3 id="ignore_date_range_2">ignore_date_range</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to stat files ignoring the date set using both --date-range-start and --date-range-end command line options.</p>
<p>This is useful when you want to set a date range for your collection, but want to stat some files regardless their last accessed, modified and changed dates.</p>
<p>Example, stat for all files and subdirecties from /etc regardless their last accessed, modified and changed dates, even if a date range was set using --date-range-start and --date-range-end command line options.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Stat all files from /etc regardless date range set by --date-range-start and --date-range-end.
    supported_os: [all]
    collector: stat
    path: /etc/*
    ignore_date_range: true
    output_file: stat_ignore_date_range.txt
</code></pre>
<h3 id="exclude_nologin_users_3">exclude_nologin_users</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to stat files from users that have a valid shell only. Any user that has no shell or a shell set as false, halt, nologin, shutdown or sync will be skipped from the collection.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Stat .bash_history file from users that have a valid shell only.
    supported_os: [all]
    collector: stat
    path: /%user_home%/.bash_history
    exclude_nologin_users: true
    output_file: stat_exclude_nologin_users.txt
</code></pre>
<h3 id="output_file_3">output_file</h3>
<p><span class="required">Required</span></p>
<p>Output file name where the stat information will be stored in. UAC never overwrites output files. Data will be appended to file if the same file name is set for a different artifact rule within the same artifact directory.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Stat all files and directories from /etc.
    supported_os: [all]
    collector: stat
    path: /etc/*
    output_file: same_output_file.txt
  -
    description: Stat all files and directories from /var/log.
    supported_os: [all]
    collector: stat
    path: /var/log/*
    output_file: same_output_file.txt
</code></pre>
<h3 id="output_directory_3">output_directory</h3>
<p><span class="optional">Optional</span></p>
<p>Defines the subdirectory name the output file will be stored in.</p>
<p>By default, collected artifacts will always be stored into a directory which its path follows the same structure defined in the artifacts directory.</p>
<p>In the example below, the output file created by <code>bodyfile.yaml</code> will be stored into <code>bodyfile</code> directory, and the output files created by <code>docker.yaml</code> will be stored into <code>live_response/containers</code> directory.</p>
<p><img alt="screenshot" src="../img/output_directory_01.png" /></p>
<p>But in some cases it is preferred to have the output file stored into subdirectories. Let's use the <code>live_response/process/string_running_processes.yaml</code> as an example where the output file is stored into <code>live_response/process/proc/%line%</code> subdirectory. </p>
<pre><code class="language-yaml">artifacts:
  -
    description: Extract strings from running processes.
    supported_os: [android, linux, netbsd]
    collector: command
    loop_command: for pid in /proc/[0-9]*; do echo ${pid} | sed -e 's:/proc/::'; done
    command: strings -a /proc/%line%/exe
    output_directory: proc/%line%
    output_file: strings.txt
    compress_output_file: true
</code></pre>
<h2 id="file-collector">file collector</h2>
<p>Use this collector to collect files and directories.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Collect all files within /var/log (recursive).
    supported_os: [all]
    collector: file
    path: /var/log/*
    file_type: f
</code></pre>
<h3 id="path_3">path</h3>
<p><span class="required">Required</span></p>
<p>The starting point from where the files will be searched for. UAC will recurse into subdirectories unless otherwise prevented by <code>max_depth</code> option.</p>
<p>As UAC uses <code>find</code> tool to search for artifacts, wildcards and regex patterns are also supported here.</p>
<p>Every file should be treated like it originates on the / (root) mount point. The root mount point will be replaced by UAC if a new mount point is set with <code>--mount-point</code> command line option.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Collect /bin/sh file.
    supported_os: [all]
    collector: file
    path: /bin/sh
</code></pre>
<p>For keeping consistences across all supported operating systems (and different <code>find</code> tool versions), it is recommended that all directory names ends with a <code>/*</code> (slash asterisks).</p>
<p>Collect all files from <code>/etc</code>. Note the use of a <code>*</code> at the end of the path.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Collect all files and directories within /etc.
    supported_os: [all]
    collector: file
    path: /etc/*
</code></pre>
<p>Note that you need to use quotation marks when specifying paths with spaces.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Collect TCC.db file.
    supported_os: [all]
    collector: file
    path: /Library/&quot;Application Support&quot;/com.apple.TCC/TCC.db
</code></pre>
<h3 id="is_file_list_2">is_file_list</h3>
<p><span class="optional">Optional</span></p>
<p>If set to true, the <code>path</code> option will refer to a file list containing one path per line. This is useful when you need to collect files based on a file list.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Collect files based on a file list located in /%uac_directory%/my_file_list.txt.
    supported_os: [all]
    collector: file
    path: /%uac_directory%/my_file_list.txt
    is_file_list: true
</code></pre>
<h3 id="path_pattern_3">path_pattern</h3>
<p><span class="optional">Optional</span></p>
<p>Return the full file path if one of path_pattern values matches the file path. This option works exactly the same way as find's -path option.</p>
<p>Don't forget to enclose the pattern in double quotes. Use backslash (\) to escape double quotes and commas.</p>
<p>As UAC uses <code>find</code> tool to search for artifacts, wildcards and regex patterns are also supported here.</p>
<p>The example below searches for Discord's Cache directory anywhere within the user's home directory. Hits would be as follows:</p>
<ul>
<li>/home/user/.config<span style="color: red;">/discord/Cache/</span>00bcecbd2455cb22_0</li>
<li>/home/user/.var/app/com.discordapp.Discord/config<span style="color: red;">/discord/Cache/</span>index</li>
<li>/home/user/snap/discord/current/.config<span style="color: red;">/discord/Cache/</span>ac0fa118bdaaa62e_0</li>
</ul>
<pre><code class="language-yaml">artifacts:
  -
    description: Find Discord cache files.
    supported_os: [all]
    collector: file
    path: /%user_home%
    path_pattern: [&quot;*/discord/Cache/*&quot;]
</code></pre>
<h3 id="name_pattern_3">name_pattern</h3>
<p><span class="optional">Optional</span></p>
<p>Return the full file path if one of the values of name_pattern matches the file name. This option works exactly the same way as find's -name option.</p>
<p>Because the leading directories are removed, the file names considered for a match with name_pattern will never include a slash, so <code>"a/b"</code> will never match anything.</p>
<p>Don't forget to enclose the pattern in double quotes. Use backslash (\) to escape double quotes and commas.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Collect all wtmp and utmp files.
    supported_os: [all]
    collector: file
    path: /var/*
    name_pattern: [&quot;wtmp&quot;, &quot;btmp&quot;]
</code></pre>
<p>As UAC uses <code>find</code> tool to search for artifacts, wildcards and regex patterns are also supported here.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Collect all HTML and TXT files.
    supported_os: [all]
    collector: file
    path: /*
    name_pattern: [&quot;*.html&quot;, &quot;*.txt&quot;]
</code></pre>
<pre><code class="language-yaml">artifacts:
  -
    description: Collect all .log and .Log (capital L) files.
    supported_os: [all]
    collector: file
    path: /var/log/*
    name_pattern: [&quot;*.[Ll]og&quot;]
</code></pre>
<h3 id="exclude_path_pattern_3">exclude_path_pattern</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to exclude paths from the collection. This option works exactly the same way as find's -path -prune option.</p>
<p>Don't forget to enclose the pattern in double quotes. Use backslash (\) to escape double quotes and commas.</p>
<p>As UAC uses <code>find</code> tool to search for artifacts, wildcards and regex patterns are also supported here.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Collect all files excluding /etc and /var.
    supported_os: [all]
    collector: file
    path: /*
    exclude_path_pattern: [&quot;/dev&quot;, &quot;/var&quot;]
</code></pre>
<h3 id="exclude_name_pattern_3">exclude_name_pattern</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to exclude files from the collection. This option works exactly the same way as find's -name -prune option.</p>
<p>Because the leading directories are removed, the file names considered for a match with exclude_name_pattern will never include a slash, so <code>"a/b"</code> will never match anything.</p>
<p>Don't forget to enclose the pattern in double quotes. Use backslash (\) to escape double quotes and commas.</p>
<p>As UAC uses <code>find</code> tool to search for artifacts, wildcards and regex patterns are also supported here.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Collect all from /etc excluding passwd and shadow* files.
    supported_os: [all]
    collector: file
    path: /etc/*
    exclude_name_pattern: [&quot;passwd&quot;, &quot;shadow*&quot;]
</code></pre>
<h3 id="exclude_file_system_3">exclude_file_system</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to exclude file systems from the collection. UAC will retrieve the list of existing mountpoints (paths) and exclude them from the collection.</p>
<p>The file system types which are supported depend on the target computer's running kernel.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Collect all files excluding any files located in procfs, nfs and devfs file systems.
    supported_os: [all]
    collector: file
    path: /*
    exclude_file_system: [procfs, nfs, devfs]
    file_type: f
</code></pre>
<h3 id="max_depth_3">max_depth</h3>
<p><span class="optional">Optional</span></p>
<p>Descend at most levels (a non-negative integer) levels of directories below the starting-point. Using 0 means only apply the tests and actions to the starting-points themselves. This option works exactly the same way as find's -maxdepth option.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Descend at most 5 levels of directories below /.
    supported_os: [all]
    collector: file
    path: /*
    max_depth: 5
</code></pre>
<h3 id="file_type_3">file_type</h3>
<p><span class="optional">Optional</span></p>
<p>This option works exactly the same way as find's -type option.</p>
<p>File is of type:</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>f</td>
<td>regular file</td>
</tr>
<tr>
<td>d</td>
<td>directory</td>
</tr>
<tr>
<td>l</td>
<td>symbolic link</td>
</tr>
<tr>
<td>p</td>
<td>named pipe (FIFO)</td>
</tr>
<tr>
<td>s</td>
<td>socket</td>
</tr>
<tr>
<td>b</td>
<td>block special</td>
</tr>
<tr>
<td>c</td>
<td>character special</td>
</tr>
</tbody>
</table>
<pre><code class="language-yaml">artifacts:
  -
    description: Collect files only.
    supported_os: [all]
    collector: file
    path: /var/log/*
    file_type: f
</code></pre>
<h3 id="min_file_size_3">min_file_size</h3>
<p><span class="optional">Optional</span></p>
<p>The minimum size of a file to stat, in bytes. Any files smaller than this will be ignored.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Collect all files bigger than 1048576 bytes.
    supported_os: [all]
    collector: file
    path: /*
    file_type: f
    min_file_size: 1048576
</code></pre>
<h3 id="max_file_size_3">max_file_size</h3>
<p><span class="optional">Optional</span></p>
<p>The maximum size of a file to stat, in bytes. Any files bigger than this will be ignored.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Collect all files smaller than 1048576 bytes.
    supported_os: [all]
    collector: file
    path: /*
    file_type: f
    max_file_size: 1048576
</code></pre>
<h3 id="permissions_3">permissions</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to collect files based on their permissions. This option works exactly the same way as find's -perm option.</p>
<p>Please note that symbolic mode is not supported (e.g: -g=w).</p>
<p>Permissions can be used as follows:</p>
<ul>
<li>File's permission bits are exactly <code>mode</code> (octal).</li>
</ul>
<pre><code class="language-yaml">artifacts:
  -
    description: Collect files that have permissions set to 755.
    supported_os: [all]
    collector: file
    path: /*
    file_type: f
    permissions: 755
</code></pre>
<ul>
<li>All of the permission bits <code>mode</code> (octal) are set for the file.</li>
</ul>
<pre><code class="language-yaml">artifacts:
  -
    description: Collect all files that have SUID bit set.
    supported_os: [all]
    collector: file
    path: /*
    file_type: f
    permissions: -4000
</code></pre>
<h3 id="ignore_date_range_3">ignore_date_range</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to collect files ignoring the date set using both --date-range-start and --date-range-end command line options.</p>
<p>This is useful when you want to set a date range for your collection, but want to collect some files regardless their last accessed, modified and changed dates.</p>
<p>Example, collect all files and subdirecties from /etc regardless their last accessed, modified and changed dates, even if a date range was set using --date-range-start and --date-range-end command line options.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Collect all files from /etc regardless date range set by --date-range-start and --date-range-end.
    supported_os: [all]
    collector: file
    path: /etc/*
    ignore_date_range: true
</code></pre>
<h3 id="exclude_nologin_users_4">exclude_nologin_users</h3>
<p><span class="optional">Optional</span></p>
<p>Use this option to collect files from users that have a valid shell only. Any user that has no shell or a shell set as false, halt, nologin, shutdown or sync will be skipped from the collection.</p>
<pre><code class="language-yaml">artifacts:
  -
    description: Collect .bash_history file from users that have a valid shell only.
    supported_os: [all]
    collector: file
    path: /%user_home%/.bash_history
    exclude_nologin_users: true
</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../artifacts_file/" class="btn btn-neutral float-left" title="Artifacts file"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../exposed_vars/" class="btn btn-neutral float-right" title="Exposed variables">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../artifacts_file/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../exposed_vars/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
